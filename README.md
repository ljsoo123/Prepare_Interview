## HTTP

---

- HTTP (Hyper Text Transfer Protocol)
- 서버와 클라이언트 간 정보 공유를 위해 사용됨
- 80번 포트 사용함
- HTTP 메소드 (GET, POST, PUT, PATCH, DELETE, OPTION) 사용<br>
  - GET : 데이터를 서버로부터 받아오기 위해 사용
  - POST : 데이터를 서버에게 전송하기 위해 사용
  - PUT : 데이터 전체 수정
  - PATCH : 데이터 일부 수정
  - DELETE : 데이터 삭제
  - OPTION : 사용 가능한 메소드 확인
- HTTP 통신은 비연결, 무상태를 지향함
  - 정보를 저장하지 않음
  - 로그인 등을 구현하기 위해 세션, 쿠키 사용됨
- HTTP 패킷
  - HTTP 패킷은 header와 body로 이루어져 있음

## TCP, UDP

---

|                |       TCP        |           UDP           |
| -------------- | :--------------: | :---------------------: |
| 연결 방식      |  연결형 서비스   |     비연결형 서비스     |
| 패킷 교환 방식 |  가상 회선 방식  |     데이터그램 방식     |
| 전송 순서      |  전송 순서 보장  | 전송 순서 보장하지 않음 |
| 수신 여부 확인 | 수신 여부 확인함 | 수신 여부 확인하지 않음 |
| 통신 방식      |     1:1통신      | 1:1 or 1:N or N:N 통신  |
| 신뢰성         |       높다       |          낮다           |
| 속도           |      느리다      |         빠르다          |

## TCP

---

- TCP에서는 3-Hand Shaking을 통해 연결하고, 4-Hand Shaking을 통해 연결을 해제한다.
  - 3-Hand Shaking<br>
  1. 클라이언트에서 서버로 SYN패킷을 보내 접속을 요청한다.
  2. 서버가 SYN 패킷을 받으면 요청을 수락한다는 뜻인 ACK와 SYN Flag가 설정된 패킷을 발송하고 클라이언트가 ACK로 응답하기를 기다린다.
  3. 클라이언트가 ACK를 서버로 보내고 이후로부터는 연결이 이루어진다.
  - 4-Hand Shaking<br>
  1. 클라이언트가 연결을 종료하겠다는 뜻인 FIN 플래그를 서버로 전송한다.
  2. 서버는 ACK메시지를 보내고 통신이 끝날 때까지 기다린다.
  3. 통신이 끝나면 서버는 클라이언트로 FIN 플래그를 전송한다.
  4. 클라이언트는 ACK 메시지를 보내고 연결이 종료된다.

## Restful API

---

- Rest API의 속성
  - 서버에 있는 리소스는 클라이언트가 바로 접근할 수 있는 URI가 존재한다.
  - 모든 요청은 클라이언트가 필요한 정보를 주기 때문에 서버에서 세션 정보를 보관할 필요가 없다.
  - HTTP 메소드를 사용한다.
  - 서비스 내의 리소스가 주변의 리소스들과 연결되어 표현되어야 한다.
- Rest API의 구성
  - Resource
    - REST에서는 자원에 접근할 때 URI를 통해 접근함.
  - HTTP 메소드
    - HTTP 메소드를 사용해 리소스에 접근함.
  - 메시지
    - 메시지는 HTTP header와 body, status code로 이루어져 있으며 header와 body에 포함된 메시지는 메시지를 처리하기 위한 충분한 정보를 포함한다.
  - Rest API 규칙
    1. URI는 정보의 자원을 표현해야 한다 (리소스명 명사 사용)
    2. 슬래시(/)는 계층 관계를 나타내는 데 사용, 마지막 문자로 슬래시를 포함하지 않는다.
    3. 하이픈(-)은 가독성을 높이는 데 사용, 밑줄(\_)은 사용하지 않는다.
    4. URI 경로에는 소문자가 적합하며, 파일 확장자는 포함시키지 않는다.

## 동기, 비동기

---

- 동기는 한 동작을 실행하는 동안 다음 동작을 실행하지 못함.
- 비동기는 한 동작을 실행하는 동안 다른 동작을 실행할 수 있음.
- 동기, 비동기 VS Blocking, Non-Blocking
  - 동기, 비동기는 호출되는 함수의 작업 완료 여부를 신경쓰느냐에 따라 구분됨.
  - Blocking, Non-blocking은 함수가 바로 return하느냐에 따라 구분됨.

## 쓰레드, 프로세스

---

- 프로세스

  - 프로세스는 독립적인 프로그램
  - 프로세스는 각각의 독립된 메모리 영역(힙, 스택, 코드, 데이터)을 가짐.
  - 프로세스가 다른 프로세스에 접근하려면 프로세스 간 통신을 사용해야 한다. 예) 파이프, 파일, 소켓 등

- 쓰레드
  - 쓰레드는 프로세스 실행되는 여러 흐름의 단위
  - 프로세스가 할당받은 자원을 이용하는 실행의 단위
  - 스레드는 프로세스 내에서 스택만 따로 할당받고 코드, 데이터, 힙 영역을 공유한다.
- 멀티 프로세스
  - 멀티 프로세싱이란 하나의 프로그램을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
  - 장점
    - 여러 개의 다른 프로세스 중 하나에 문제가 발생하면 그 자식 프로세스가 죽는 것 이상의 문제가 생기지 않는다.
  - 단점
    - Context Switching 과정에서 캐쉬 메모리 초기화 등 무거운 작업이 실행되고 많은 시간이 소모되는 등 오버헤드가 발생한다.
    - 프로세스는 각각의 독립된 메모리를 가지기 때문에 프로세스 사이에서 공유하는 메모리가 없어 Context Switching이 발생하면 캐쉬에 있는 데이터를 모두 리셋하고 다시 캐쉬 정보를 불러와야 한다.
    - 프로세스는 각각의 독립된 메모리를 가지기 때문에 하나의 프로그램에 속하는 프로세스들 사이의 변수를 공유할 수 없다.
- 멀티 쓰레드
  - 멀티 쓰레드란 하나의 응용 프로그램을 여러 개의 쓰레드로 구성하고 각 쓰레드로 하여금 하나의 작업을 처리하도록 하는 것이다.
  - 장점
    - 프로세스를 생성하는 것보다 자원을 효율적으로 관리할 수 있다.
    - 스레드 간 데이터를 주고받는 것이 간단해지고 시스템 자원 소모가 줄어들게 된다.
    - Context Switching 이 빠르다.
    - 스레드는 프로세스 내의 Stack영역을 제외한 모든 메모리를 공유하기 때문에 통신의 부담이 적다.
  - 단점
    - 주의 깊은 설계가 필요하다.
    - 자원 공유의 문제가 일어난다.
    - 단일 프로세스 시스템의 경우 효과를 기대하기 어렵다.
    - 하나의 스레드에 문제가 발생하면 전체 프로세스가 영향을 받는다.
  - Context Switching이란?
    - CPU에서 여러 프로세스를 돌아가면서 작업을 처리하는데, 이 과정을 Context Switching 이라고 한다.
    - 동작 중인 프로세스가 대기를 하면서 해당 프로세스의 상태를 보관하고, 대기하고 있던 다음 순서의 프로세스가 동작하면서 이전에 보관했던 프로세스의 상태를 복구하는 작업을 말한다.
- 멀티 프로세스 대신 멀티 쓰레드를 사용하는 이유
  - 자원의 효율성 증대
    - 멀티 프로세스로 실행되는 작업을 멀티 쓰레드로 실행하면 프로세스를 생성하여 자원을 할당하는 시스템 콜이 줄어들어 자원을 효율적으로 관리할 수 있다.
    - 프로세스 간의 Context Switching보다 쓰레드 간의 Context Switching이 자원 소모가 덜하다.
    - 쓰레드는 메모리를 공유하기 때문에 독립적인 프로세스와 달리 데이터를 주고 받는 것이 간단해지고 자원 소모가 덜하다.
- 멀티 쓰레드 사용시 주의할 점
  - 임계 영역
    - 둘 이상의 쓰레드가 동시에 실행될 경우 생길 수 있는 동시 접근 문제를 발생시킬 수 있는 코드 블럭. 경쟁 상태를 일으킬 수 있다.
  - 경쟁 상태
    - 여러 쓰레드가 공유 데이터를 동시에 접근할 때 공유 데이터에 대한 실행 순서에 따라 실행 결과가 달라짐
  - 동기화
    - 임계영역을 보호하기 위해 쓰레드들에게 하나의 자원에 대한 처리 권한을 주거나 순서를 조정해주는 기법
- 동기화 기법
  - 뮤텍스
    - 공유된 자원의 데이터를 여러 쓰레드가 접근하는 것을 막는 것. 오직 하나의 쓰레드만이 뮤텍스를 얻어 임계 영역에 접근이 가능하다. 그리고 해당 쓰레드만이 임계 영역에서 나갈 때 뮤텍스를 해제할 수 있다.
  - 세마포어
    - 공유된 자원의 데이터를 세마포어 값 만큼만 접근하도록 막는 것. 정수 변수 값을 지정해두고 쓰레드가 임계 영역에 접근할 때마다 변수의 값을 감소시킨다. 그리고 변수의 값이 0인 상태에서 쓰레드가 임계영역에 접근할 때 차단시킨다.
  - 뮤텍스 VS 세마포어
    - 세마포어는 값을 1로 설정하면 뮤텍스로 사용할 수 있다. 뮤텍스는 세마포어를 대체할 수 없다.
    - 세마포어는 소유가 불가능하다. 뮤텍스는 소유가 가능하며 뮤텍스를 소유하는 쓰레드가 책임을 진다.
    - 세마포어는 동기화 대상이 여러 개일 때, 뮤텍스는 하나일 때 사용한다.
- 교착 상태
  - 서로 다른 쓰레드가 점유하고 있는 자원의 반납을 대기하는 상태
  - 발생 조건
    - 상호 배제 : 한번에 한 프로세스만 자원을 사용할 수 있다.
    - 점유 대기 : 할당된 자원을 가진 상태에서 다른 자원을 기다린다.
    - 비선점 : 다른 프로세스가 자원의 사용을 끝낼 때까지 자원을 뺏을 수 없다.
    - 순환 대기 : 각 프로세스가 순환적으로 다음 프로세스가 요구하는 자원을 가지고 있다.
  - 해결 방법
    - 예방 : 발생 조건 중 하나를 일어나지 않게 만든다.
    - 회피 : 교착상태가 발견될 수 없도록 알고리즘을 작성한다.
    - 회복 : 교착상태 발견 시, 해결한다.

## CPU 스케줄링

---

- CPU 스케줄링
  - 메모리에 올라온 프로세스들 중 어떤 프로세스를 먼저 처리할지 순서를 정하는 것
  - 프로세스들이 CPU를 보다 효율적으로 사용하기 위함
  - CPU 스케줄러는 다음 네 가지 상황에서 동작한다.
    - 한 프로세스가 실행상태에서 대기 상태로 전환될 때
    - 프로세스가 실행 상태에서 준비 완료 상태로 전환될 때
    - 프로세스가 대기 상태에서 준비완료 상태로 전환될 때
    - 프로세스가 종료될 때
  - 1, 4번 상황과 같이 프로세스가 자발적으로 CPU를 반환하는 경우, 이러한 스케줄링 방법을 비선점이라고 한다.
  - 2, 3번 상황과 같이 강제적으로 CPU를 빼앗기는 경우, 이러한 스케줄링 방법을 선점이라고 한다.
- 선점 스케줄링
  - SRT 스케줄링
    - 짧은 시간 순서대로 프로세스를 처리한다. 남은 처리 시간이 더 짧은 프로세스가 Ready 큐에 들어오면 그 프로세스가 바로 선점된다.
  - 라운드로빈 스케줄링
    - 각 프로세스는 같은 크기의 CPU 시간을 할당 받고 선입선출에 의해 실행된다. 할당시간이 너무 크면 선입선출과 다를 바가 없어지고, 너무 작으면 오버헤드가 너무 커진다.
  - 다단계 큐 스케줄링
    - Ready 큐를 여러 개 사용하는 기법. 각각의 큐는 자신의 스케줄링 알고리즘을 수행하며, 큐와 큐 사이에도 우선순위를 부여한다.
  - 다단계 피드백 큐 스케줄링
    - 다단계 큐와 비슷하나 프로세스들이 큐를 이동할 수 있다.
- 비선점 스케줄링
  - HRN 스케줄링
    - 긴 작업과 짧은 작업간의 지나친 불평등을 어느 정도 보완한 기법. 수행시간의 길이와 대기 시간을 모두 고려해 우선순위를 정한다.
  - SJF 스케줄링
    - 큐 안에 있는 프로세스 중 수행시간이 짧은 것을 먼저 수행. 평균 대기 시간을 감소시킨다.
  - 우선순위 스케줄링
    - 프로세스에게 우선순위를 정적, 혹은 동적으로 부여하여 우선순위가 높은 순서대로 처리한다. 동적으로 부여할 경우 구현이 복잡하고 오버헤드가 많다는 단점이 있으나, 시스템의 응답속도를 증가시킨다.
  - 기한부 스케줄링
    - 작업을 명시된 시간이나 기한 내에 완료하도록 계획
  - FIFO 스케줄링
    - 프로세스들은 Ready 큐에 도착한 순서대로 CPU를 할당받는다. 작업 완료 시간을 예측하기 매우 용이하다. 하지만 덜 중요한 작업을 기다리게 할 수도 있다.

## GC(가비지 컬렉터)

---

- 메모리 주기
  - 메모리 주기는 할당, 사용, 해제로 이루어져 있다.
  - 가바지 컬렉터는 메모리를 해제하는 부분에서 필요하며, 대부분의 고급 언어에서는 GC가 구현되어 있다.
- 가비지 컬렉터
  - 메모리를 해제할 때 사용하지 않는 메모리를 해제해야 하는데, 이를 알고리즘으로 구현할 수 없다.
  - 따라서, 가비지 컬렉터는 제한적인 해결책을 제안한다.
  - 참조-세기 가비지 콜렉션
    - 이 알고리즘은 더 이상 참조되지 않는 객체를 찾아 해제한다.
    - 참조-세기 알고리즘은 순환 참조 문제가 나타난다. 순환하는 객체가 서로를 참조하고 있기 때문에 필요 없는 메모리를 회수하지 못한다.
  - Mark-And-Sweep 알고리즘
    - 이 알고리즘은 "더 이상 닿을 수 없는 오브젝트"를 "닿을 수 없는 오브젝트"로 정의한다.
    - 이 알고리즘은 root(자바스크립트에서는 전역변수)로부터 시작하여 root가 참조하는 오브젝트를 "닿을 수 있는 오브젝트"라고 정의한다. "닿을 수 있는 오브젝트"를 제외한 오브젝트들에 대해 가비지 컬렉션을 진행한다.
    - 순환 참조가 일어나도 root에 닿지 않으면 가비지 컬렉션이 진행된다.

## 테스트 코드

---

- 소프트웨어 관점의 테스트
  - 프로그램을 실행하여 오류와 결함을 검출하고 애플리케이션이 요구사항에 맞게 동작하는지 검증하는 절차.
- 테스트의 목적
  - 테스트를 하는 목적은 발생 가능한 결함을 예방하고 애플리케이션이 요구사항을 충족하는지 확인하는 데에 있다.
  - 테스트를 하면 개발 과정에서 생기는 변경 사항들로 인해 새로운 결함이 유입되지 않았는지 확인할 수 있다.
  - 따라서 더 적극적으로 리팩토링 및 코드 개선을 할 수 있어 코드 품질이 향상된다.
- 테스트의 유형
  - 오늘날 테스트의 유형을 구분 짓는 많은 가이드에 의하면 테스트는 정적 테스트, 단위 테스트, 통합 테스트, E2E(End to End)테스트로 구분지을 수 있다.
  - 정적 테스트 (Static Test)
    - 정적 테스트는 코드를 실행시키지 않고 테스트를 하는 것을 말한다.
    - 정적 테스트를 하면 Type 에러나 Reference 에러와 같은 개발자의 실수로 인해 나타나는 에러들을 방지할 수 있다.
    - 많은 개발자의 노하우에 의해 만들어진 규칙에 따라 코드를 분석하는 것은 더 좋은 코드를 작성할 수 있는 습관을 기르도록 도와준다.
  - 단위 테스트 (Unit Test)
    - 단위 테스트는 각 모듈을 단독 실행 환경에서 독립적으로 테스트하는 것을 말한다.
    - 프론트엔드에서 단위 테스트는 특정 컴포넌트를 렌더링해서 깨지지 않는지 확인하는 것을 예로 들 수 있다.
  - 통합 테스트 (Integration Test)
    - 통합 테스트는 두 개 이상의 모듈이 실제로 연결된 상태를 테스트하는 것을 말한다.
    - 모듈 간의 연결에서 발생하는 에러를 검증할 수 있다.
    - 단위 테스트보다 비교적 넓은 범위에서 실행하기 때문에 리팩토링에 쉽게 깨지지 않는다.
    - 프론트엔드에서 통합 테스트는 UI와 API간의 상호 작용이 잘 이루어지는지, 또는 state에 따라 UI 변경이 잘 일어나는지를 확인하는 것을 예로 들 수 있다.
  - E2E Test
    - E2E Test는 실제 사용자의 입장에서 테스트하는 것을 말한다.
    - 프론트엔드에서 E2E 테스트는 실제 브라우저를 테스트하는 것을 말한다.
    - 실제 상황에서 발생할 수 있는 에러를 검출할 수 있다.
